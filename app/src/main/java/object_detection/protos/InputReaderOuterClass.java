/*
 * Copyright (c) 2019. Kin-Hong Wong. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ==============================================================================
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/input_reader.proto

package object_detection.protos;

public final class InputReaderOuterClass {
  private InputReaderOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * Instance mask format. Note that PNG masks are much more space efficient.
   * </pre>
   *
   * Protobuf enum {@code object_detection.protos.InstanceMaskType}
   */
  public enum InstanceMaskType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Default implementation, currently NUMERICAL_MASKS
     * </pre>
     *
     * <code>DEFAULT = 0;</code>
     */
    DEFAULT(0),
    /**
     * <pre>
     * [num_masks, H, W] float32 binary masks.
     * </pre>
     *
     * <code>NUMERICAL_MASKS = 1;</code>
     */
    NUMERICAL_MASKS(1),
    /**
     * <pre>
     * Encoded PNG masks.
     * </pre>
     *
     * <code>PNG_MASKS = 2;</code>
     */
    PNG_MASKS(2),
    ;

    /**
     * <pre>
     * Default implementation, currently NUMERICAL_MASKS
     * </pre>
     *
     * <code>DEFAULT = 0;</code>
     */
    public static final int DEFAULT_VALUE = 0;
    /**
     * <pre>
     * [num_masks, H, W] float32 binary masks.
     * </pre>
     *
     * <code>NUMERICAL_MASKS = 1;</code>
     */
    public static final int NUMERICAL_MASKS_VALUE = 1;
    /**
     * <pre>
     * Encoded PNG masks.
     * </pre>
     *
     * <code>PNG_MASKS = 2;</code>
     */
    public static final int PNG_MASKS_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static InstanceMaskType valueOf(int value) {
      return forNumber(value);
    }

    public static InstanceMaskType forNumber(int value) {
      switch (value) {
        case 0: return DEFAULT;
        case 1: return NUMERICAL_MASKS;
        case 2: return PNG_MASKS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InstanceMaskType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        InstanceMaskType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<InstanceMaskType>() {
            public InstanceMaskType findValueByNumber(int number) {
              return InstanceMaskType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.getDescriptor().getEnumTypes().get(0);
    }

    private static final InstanceMaskType[] VALUES = values();

    public static InstanceMaskType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private InstanceMaskType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:object_detection.protos.InstanceMaskType)
  }

  public interface InputReaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.InputReader)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     */
    boolean hasName();
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     */
    boolean hasLabelMapPath();
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     */
    java.lang.String getLabelMapPath();
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     */
    com.google.protobuf.ByteString
        getLabelMapPathBytes();

    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     */
    boolean hasShuffle();
    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     */
    boolean getShuffle();

    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     */
    boolean hasShuffleBufferSize();
    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     */
    int getShuffleBufferSize();

    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     */
    boolean hasFilenamesShuffleBufferSize();
    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     */
    int getFilenamesShuffleBufferSize();

    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     */
    boolean hasNumEpochs();
    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     */
    int getNumEpochs();

    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     */
    boolean hasSample1OfNExamples();
    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     */
    int getSample1OfNExamples();

    /**
     * <pre>
     * Number of file shards to read in parallel.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     */
    boolean hasNumReaders();
    /**
     * <pre>
     * Number of file shards to read in parallel.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     */
    int getNumReaders();

    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     */
    boolean hasNumParallelBatches();
    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     */
    int getNumParallelBatches();

    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     */
    boolean hasNumPrefetchBatches();
    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     */
    int getNumPrefetchBatches();

    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     */
    @java.lang.Deprecated boolean hasQueueCapacity();
    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     */
    @java.lang.Deprecated int getQueueCapacity();

    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     */
    @java.lang.Deprecated boolean hasMinAfterDequeue();
    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     */
    @java.lang.Deprecated int getMinAfterDequeue();

    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     */
    boolean hasReadBlockLength();
    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     */
    int getReadBlockLength();

    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     */
    @java.lang.Deprecated boolean hasPrefetchSize();
    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     */
    @java.lang.Deprecated int getPrefetchSize();

    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     */
    @java.lang.Deprecated boolean hasNumParallelMapCalls();
    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     */
    @java.lang.Deprecated int getNumParallelMapCalls();

    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     */
    boolean hasNumAdditionalChannels();
    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     */
    int getNumAdditionalChannels();

    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     */
    boolean hasNumKeypoints();
    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     */
    int getNumKeypoints();

    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     */
    boolean hasMaxNumberOfBoxes();
    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     */
    int getMaxNumberOfBoxes();

    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     */
    boolean hasLoadInstanceMasks();
    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     */
    boolean getLoadInstanceMasks();

    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     */
    boolean hasMaskType();
    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     */
    object_detection.protos.InputReaderOuterClass.InstanceMaskType getMaskType();

    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     */
    boolean hasUseDisplayName();
    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     */
    boolean getUseDisplayName();

    /**
     * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    boolean hasTfRecordInputReader();
    /**
     * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    object_detection.protos.InputReaderOuterClass.TFRecordInputReader getTfRecordInputReader();
    /**
     * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder getTfRecordInputReaderOrBuilder();

    /**
     * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    boolean hasExternalInputReader();
    /**
     * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    object_detection.protos.InputReaderOuterClass.ExternalInputReader getExternalInputReader();
    /**
     * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder getExternalInputReaderOrBuilder();

    public object_detection.protos.InputReaderOuterClass.InputReader.InputReaderCase getInputReaderCase();
  }
  /**
   * <pre>
   * Next id: 24
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.InputReader}
   */
  public  static final class InputReader extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.InputReader)
      InputReaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InputReader.newBuilder() to construct.
    private InputReader(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InputReader() {
      name_ = "";
      labelMapPath_ = "";
      shuffle_ = true;
      shuffleBufferSize_ = 2048;
      filenamesShuffleBufferSize_ = 100;
      numEpochs_ = 0;
      sample1OfNExamples_ = 1;
      numReaders_ = 64;
      numParallelBatches_ = 8;
      numPrefetchBatches_ = 2;
      queueCapacity_ = 2000;
      minAfterDequeue_ = 1000;
      readBlockLength_ = 32;
      prefetchSize_ = 512;
      numParallelMapCalls_ = 64;
      numAdditionalChannels_ = 0;
      numKeypoints_ = 0;
      maxNumberOfBoxes_ = 100;
      loadInstanceMasks_ = false;
      maskType_ = 1;
      useDisplayName_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private InputReader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              labelMapPath_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000004;
              shuffle_ = input.readBool();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000400;
              queueCapacity_ = input.readUInt32();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000800;
              minAfterDequeue_ = input.readUInt32();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000020;
              numEpochs_ = input.readUInt32();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000080;
              numReaders_ = input.readUInt32();
              break;
            }
            case 56: {
              bitField0_ |= 0x00040000;
              loadInstanceMasks_ = input.readBool();
              break;
            }
            case 66: {
              object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder subBuilder = null;
              if (inputReaderCase_ == 8) {
                subBuilder = ((object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_).toBuilder();
              }
              inputReader_ =
                  input.readMessage(object_detection.protos.InputReaderOuterClass.TFRecordInputReader.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_);
                inputReader_ = subBuilder.buildPartial();
              }
              inputReaderCase_ = 8;
              break;
            }
            case 74: {
              object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder subBuilder = null;
              if (inputReaderCase_ == 9) {
                subBuilder = ((object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_).toBuilder();
              }
              inputReader_ =
                  input.readMessage(object_detection.protos.InputReaderOuterClass.ExternalInputReader.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_);
                inputReader_ = subBuilder.buildPartial();
              }
              inputReaderCase_ = 9;
              break;
            }
            case 80: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              object_detection.protos.InputReaderOuterClass.InstanceMaskType value = object_detection.protos.InputReaderOuterClass.InstanceMaskType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(10, rawValue);
              } else {
                bitField0_ |= 0x00080000;
                maskType_ = rawValue;
              }
              break;
            }
            case 88: {
              bitField0_ |= 0x00000008;
              shuffleBufferSize_ = input.readUInt32();
              break;
            }
            case 96: {
              bitField0_ |= 0x00000010;
              filenamesShuffleBufferSize_ = input.readUInt32();
              break;
            }
            case 104: {
              bitField0_ |= 0x00002000;
              prefetchSize_ = input.readUInt32();
              break;
            }
            case 112: {
              bitField0_ |= 0x00004000;
              numParallelMapCalls_ = input.readUInt32();
              break;
            }
            case 120: {
              bitField0_ |= 0x00001000;
              readBlockLength_ = input.readUInt32();
              break;
            }
            case 128: {
              bitField0_ |= 0x00010000;
              numKeypoints_ = input.readUInt32();
              break;
            }
            case 136: {
              bitField0_ |= 0x00100000;
              useDisplayName_ = input.readBool();
              break;
            }
            case 144: {
              bitField0_ |= 0x00008000;
              numAdditionalChannels_ = input.readInt32();
              break;
            }
            case 152: {
              bitField0_ |= 0x00000100;
              numParallelBatches_ = input.readUInt32();
              break;
            }
            case 160: {
              bitField0_ |= 0x00000200;
              numPrefetchBatches_ = input.readInt32();
              break;
            }
            case 168: {
              bitField0_ |= 0x00020000;
              maxNumberOfBoxes_ = input.readInt32();
              break;
            }
            case 176: {
              bitField0_ |= 0x00000040;
              sample1OfNExamples_ = input.readUInt32();
              break;
            }
            case 186: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.InputReaderOuterClass.InputReader.class, object_detection.protos.InputReaderOuterClass.InputReader.Builder.class);
    }

    private int bitField0_;
    private int inputReaderCase_ = 0;
    private java.lang.Object inputReader_;
    public enum InputReaderCase
        implements com.google.protobuf.Internal.EnumLite {
      TF_RECORD_INPUT_READER(8),
      EXTERNAL_INPUT_READER(9),
      INPUTREADER_NOT_SET(0);
      private final int value;
      private InputReaderCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputReaderCase valueOf(int value) {
        return forNumber(value);
      }

      public static InputReaderCase forNumber(int value) {
        switch (value) {
          case 8: return TF_RECORD_INPUT_READER;
          case 9: return EXTERNAL_INPUT_READER;
          case 0: return INPUTREADER_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public InputReaderCase
    getInputReaderCase() {
      return InputReaderCase.forNumber(
          inputReaderCase_);
    }

    public static final int NAME_FIELD_NUMBER = 23;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LABEL_MAP_PATH_FIELD_NUMBER = 1;
    private volatile java.lang.Object labelMapPath_;
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     */
    public boolean hasLabelMapPath() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     */
    public java.lang.String getLabelMapPath() {
      java.lang.Object ref = labelMapPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          labelMapPath_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     */
    public com.google.protobuf.ByteString
        getLabelMapPathBytes() {
      java.lang.Object ref = labelMapPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        labelMapPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SHUFFLE_FIELD_NUMBER = 2;
    private boolean shuffle_;
    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     */
    public boolean hasShuffle() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     */
    public boolean getShuffle() {
      return shuffle_;
    }

    public static final int SHUFFLE_BUFFER_SIZE_FIELD_NUMBER = 11;
    private int shuffleBufferSize_;
    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     */
    public boolean hasShuffleBufferSize() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     */
    public int getShuffleBufferSize() {
      return shuffleBufferSize_;
    }

    public static final int FILENAMES_SHUFFLE_BUFFER_SIZE_FIELD_NUMBER = 12;
    private int filenamesShuffleBufferSize_;
    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     */
    public boolean hasFilenamesShuffleBufferSize() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     */
    public int getFilenamesShuffleBufferSize() {
      return filenamesShuffleBufferSize_;
    }

    public static final int NUM_EPOCHS_FIELD_NUMBER = 5;
    private int numEpochs_;
    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     */
    public boolean hasNumEpochs() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     */
    public int getNumEpochs() {
      return numEpochs_;
    }

    public static final int SAMPLE_1_OF_N_EXAMPLES_FIELD_NUMBER = 22;
    private int sample1OfNExamples_;
    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     */
    public boolean hasSample1OfNExamples() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     */
    public int getSample1OfNExamples() {
      return sample1OfNExamples_;
    }

    public static final int NUM_READERS_FIELD_NUMBER = 6;
    private int numReaders_;
    /**
     * <pre>
     * Number of file shards to read in parallel.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     */
    public boolean hasNumReaders() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * Number of file shards to read in parallel.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     */
    public int getNumReaders() {
      return numReaders_;
    }

    public static final int NUM_PARALLEL_BATCHES_FIELD_NUMBER = 19;
    private int numParallelBatches_;
    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     */
    public boolean hasNumParallelBatches() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     */
    public int getNumParallelBatches() {
      return numParallelBatches_;
    }

    public static final int NUM_PREFETCH_BATCHES_FIELD_NUMBER = 20;
    private int numPrefetchBatches_;
    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     */
    public boolean hasNumPrefetchBatches() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     */
    public int getNumPrefetchBatches() {
      return numPrefetchBatches_;
    }

    public static final int QUEUE_CAPACITY_FIELD_NUMBER = 3;
    private int queueCapacity_;
    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasQueueCapacity() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     */
    @java.lang.Deprecated public int getQueueCapacity() {
      return queueCapacity_;
    }

    public static final int MIN_AFTER_DEQUEUE_FIELD_NUMBER = 4;
    private int minAfterDequeue_;
    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasMinAfterDequeue() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     */
    @java.lang.Deprecated public int getMinAfterDequeue() {
      return minAfterDequeue_;
    }

    public static final int READ_BLOCK_LENGTH_FIELD_NUMBER = 15;
    private int readBlockLength_;
    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     */
    public boolean hasReadBlockLength() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     */
    public int getReadBlockLength() {
      return readBlockLength_;
    }

    public static final int PREFETCH_SIZE_FIELD_NUMBER = 13;
    private int prefetchSize_;
    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasPrefetchSize() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     */
    @java.lang.Deprecated public int getPrefetchSize() {
      return prefetchSize_;
    }

    public static final int NUM_PARALLEL_MAP_CALLS_FIELD_NUMBER = 14;
    private int numParallelMapCalls_;
    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasNumParallelMapCalls() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     */
    @java.lang.Deprecated public int getNumParallelMapCalls() {
      return numParallelMapCalls_;
    }

    public static final int NUM_ADDITIONAL_CHANNELS_FIELD_NUMBER = 18;
    private int numAdditionalChannels_;
    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     */
    public boolean hasNumAdditionalChannels() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     */
    public int getNumAdditionalChannels() {
      return numAdditionalChannels_;
    }

    public static final int NUM_KEYPOINTS_FIELD_NUMBER = 16;
    private int numKeypoints_;
    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     */
    public boolean hasNumKeypoints() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     */
    public int getNumKeypoints() {
      return numKeypoints_;
    }

    public static final int MAX_NUMBER_OF_BOXES_FIELD_NUMBER = 21;
    private int maxNumberOfBoxes_;
    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     */
    public boolean hasMaxNumberOfBoxes() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     */
    public int getMaxNumberOfBoxes() {
      return maxNumberOfBoxes_;
    }

    public static final int LOAD_INSTANCE_MASKS_FIELD_NUMBER = 7;
    private boolean loadInstanceMasks_;
    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     */
    public boolean hasLoadInstanceMasks() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     */
    public boolean getLoadInstanceMasks() {
      return loadInstanceMasks_;
    }

    public static final int MASK_TYPE_FIELD_NUMBER = 10;
    private int maskType_;
    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     */
    public boolean hasMaskType() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     */
    public object_detection.protos.InputReaderOuterClass.InstanceMaskType getMaskType() {
      @SuppressWarnings("deprecation")
      object_detection.protos.InputReaderOuterClass.InstanceMaskType result = object_detection.protos.InputReaderOuterClass.InstanceMaskType.valueOf(maskType_);
      return result == null ? object_detection.protos.InputReaderOuterClass.InstanceMaskType.NUMERICAL_MASKS : result;
    }

    public static final int USE_DISPLAY_NAME_FIELD_NUMBER = 17;
    private boolean useDisplayName_;
    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     */
    public boolean hasUseDisplayName() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     */
    public boolean getUseDisplayName() {
      return useDisplayName_;
    }

    public static final int TF_RECORD_INPUT_READER_FIELD_NUMBER = 8;
    /**
     * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    public boolean hasTfRecordInputReader() {
      return inputReaderCase_ == 8;
    }
    /**
     * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getTfRecordInputReader() {
      if (inputReaderCase_ == 8) {
         return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
    }
    /**
     * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    public object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder getTfRecordInputReaderOrBuilder() {
      if (inputReaderCase_ == 8) {
         return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
    }

    public static final int EXTERNAL_INPUT_READER_FIELD_NUMBER = 9;
    /**
     * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    public boolean hasExternalInputReader() {
      return inputReaderCase_ == 9;
    }
    /**
     * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    public object_detection.protos.InputReaderOuterClass.ExternalInputReader getExternalInputReader() {
      if (inputReaderCase_ == 9) {
         return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
    }
    /**
     * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    public object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder getExternalInputReaderOrBuilder() {
      if (inputReaderCase_ == 9) {
         return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasExternalInputReader()) {
        if (!getExternalInputReader().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, labelMapPath_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(2, shuffle_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeUInt32(3, queueCapacity_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeUInt32(4, minAfterDequeue_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeUInt32(5, numEpochs_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeUInt32(6, numReaders_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeBool(7, loadInstanceMasks_);
      }
      if (inputReaderCase_ == 8) {
        output.writeMessage(8, (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_);
      }
      if (inputReaderCase_ == 9) {
        output.writeMessage(9, (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeEnum(10, maskType_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt32(11, shuffleBufferSize_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeUInt32(12, filenamesShuffleBufferSize_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeUInt32(13, prefetchSize_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeUInt32(14, numParallelMapCalls_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeUInt32(15, readBlockLength_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeUInt32(16, numKeypoints_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeBool(17, useDisplayName_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeInt32(18, numAdditionalChannels_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeUInt32(19, numParallelBatches_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt32(20, numPrefetchBatches_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(21, maxNumberOfBoxes_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeUInt32(22, sample1OfNExamples_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 23, name_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, labelMapPath_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, shuffle_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, queueCapacity_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, minAfterDequeue_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, numEpochs_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, numReaders_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, loadInstanceMasks_);
      }
      if (inputReaderCase_ == 8) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_);
      }
      if (inputReaderCase_ == 9) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, maskType_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, shuffleBufferSize_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, filenamesShuffleBufferSize_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(13, prefetchSize_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(14, numParallelMapCalls_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(15, readBlockLength_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(16, numKeypoints_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(17, useDisplayName_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(18, numAdditionalChannels_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(19, numParallelBatches_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(20, numPrefetchBatches_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(21, maxNumberOfBoxes_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(22, sample1OfNExamples_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, name_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.InputReaderOuterClass.InputReader)) {
        return super.equals(obj);
      }
      object_detection.protos.InputReaderOuterClass.InputReader other = (object_detection.protos.InputReaderOuterClass.InputReader) obj;

      boolean result = true;
      result = result && (hasName() == other.hasName());
      if (hasName()) {
        result = result && getName()
            .equals(other.getName());
      }
      result = result && (hasLabelMapPath() == other.hasLabelMapPath());
      if (hasLabelMapPath()) {
        result = result && getLabelMapPath()
            .equals(other.getLabelMapPath());
      }
      result = result && (hasShuffle() == other.hasShuffle());
      if (hasShuffle()) {
        result = result && (getShuffle()
            == other.getShuffle());
      }
      result = result && (hasShuffleBufferSize() == other.hasShuffleBufferSize());
      if (hasShuffleBufferSize()) {
        result = result && (getShuffleBufferSize()
            == other.getShuffleBufferSize());
      }
      result = result && (hasFilenamesShuffleBufferSize() == other.hasFilenamesShuffleBufferSize());
      if (hasFilenamesShuffleBufferSize()) {
        result = result && (getFilenamesShuffleBufferSize()
            == other.getFilenamesShuffleBufferSize());
      }
      result = result && (hasNumEpochs() == other.hasNumEpochs());
      if (hasNumEpochs()) {
        result = result && (getNumEpochs()
            == other.getNumEpochs());
      }
      result = result && (hasSample1OfNExamples() == other.hasSample1OfNExamples());
      if (hasSample1OfNExamples()) {
        result = result && (getSample1OfNExamples()
            == other.getSample1OfNExamples());
      }
      result = result && (hasNumReaders() == other.hasNumReaders());
      if (hasNumReaders()) {
        result = result && (getNumReaders()
            == other.getNumReaders());
      }
      result = result && (hasNumParallelBatches() == other.hasNumParallelBatches());
      if (hasNumParallelBatches()) {
        result = result && (getNumParallelBatches()
            == other.getNumParallelBatches());
      }
      result = result && (hasNumPrefetchBatches() == other.hasNumPrefetchBatches());
      if (hasNumPrefetchBatches()) {
        result = result && (getNumPrefetchBatches()
            == other.getNumPrefetchBatches());
      }
      result = result && (hasQueueCapacity() == other.hasQueueCapacity());
      if (hasQueueCapacity()) {
        result = result && (getQueueCapacity()
            == other.getQueueCapacity());
      }
      result = result && (hasMinAfterDequeue() == other.hasMinAfterDequeue());
      if (hasMinAfterDequeue()) {
        result = result && (getMinAfterDequeue()
            == other.getMinAfterDequeue());
      }
      result = result && (hasReadBlockLength() == other.hasReadBlockLength());
      if (hasReadBlockLength()) {
        result = result && (getReadBlockLength()
            == other.getReadBlockLength());
      }
      result = result && (hasPrefetchSize() == other.hasPrefetchSize());
      if (hasPrefetchSize()) {
        result = result && (getPrefetchSize()
            == other.getPrefetchSize());
      }
      result = result && (hasNumParallelMapCalls() == other.hasNumParallelMapCalls());
      if (hasNumParallelMapCalls()) {
        result = result && (getNumParallelMapCalls()
            == other.getNumParallelMapCalls());
      }
      result = result && (hasNumAdditionalChannels() == other.hasNumAdditionalChannels());
      if (hasNumAdditionalChannels()) {
        result = result && (getNumAdditionalChannels()
            == other.getNumAdditionalChannels());
      }
      result = result && (hasNumKeypoints() == other.hasNumKeypoints());
      if (hasNumKeypoints()) {
        result = result && (getNumKeypoints()
            == other.getNumKeypoints());
      }
      result = result && (hasMaxNumberOfBoxes() == other.hasMaxNumberOfBoxes());
      if (hasMaxNumberOfBoxes()) {
        result = result && (getMaxNumberOfBoxes()
            == other.getMaxNumberOfBoxes());
      }
      result = result && (hasLoadInstanceMasks() == other.hasLoadInstanceMasks());
      if (hasLoadInstanceMasks()) {
        result = result && (getLoadInstanceMasks()
            == other.getLoadInstanceMasks());
      }
      result = result && (hasMaskType() == other.hasMaskType());
      if (hasMaskType()) {
        result = result && maskType_ == other.maskType_;
      }
      result = result && (hasUseDisplayName() == other.hasUseDisplayName());
      if (hasUseDisplayName()) {
        result = result && (getUseDisplayName()
            == other.getUseDisplayName());
      }
      result = result && getInputReaderCase().equals(
          other.getInputReaderCase());
      if (!result) return false;
      switch (inputReaderCase_) {
        case 8:
          result = result && getTfRecordInputReader()
              .equals(other.getTfRecordInputReader());
          break;
        case 9:
          result = result && getExternalInputReader()
              .equals(other.getExternalInputReader());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasLabelMapPath()) {
        hash = (37 * hash) + LABEL_MAP_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getLabelMapPath().hashCode();
      }
      if (hasShuffle()) {
        hash = (37 * hash) + SHUFFLE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getShuffle());
      }
      if (hasShuffleBufferSize()) {
        hash = (37 * hash) + SHUFFLE_BUFFER_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getShuffleBufferSize();
      }
      if (hasFilenamesShuffleBufferSize()) {
        hash = (37 * hash) + FILENAMES_SHUFFLE_BUFFER_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getFilenamesShuffleBufferSize();
      }
      if (hasNumEpochs()) {
        hash = (37 * hash) + NUM_EPOCHS_FIELD_NUMBER;
        hash = (53 * hash) + getNumEpochs();
      }
      if (hasSample1OfNExamples()) {
        hash = (37 * hash) + SAMPLE_1_OF_N_EXAMPLES_FIELD_NUMBER;
        hash = (53 * hash) + getSample1OfNExamples();
      }
      if (hasNumReaders()) {
        hash = (37 * hash) + NUM_READERS_FIELD_NUMBER;
        hash = (53 * hash) + getNumReaders();
      }
      if (hasNumParallelBatches()) {
        hash = (37 * hash) + NUM_PARALLEL_BATCHES_FIELD_NUMBER;
        hash = (53 * hash) + getNumParallelBatches();
      }
      if (hasNumPrefetchBatches()) {
        hash = (37 * hash) + NUM_PREFETCH_BATCHES_FIELD_NUMBER;
        hash = (53 * hash) + getNumPrefetchBatches();
      }
      if (hasQueueCapacity()) {
        hash = (37 * hash) + QUEUE_CAPACITY_FIELD_NUMBER;
        hash = (53 * hash) + getQueueCapacity();
      }
      if (hasMinAfterDequeue()) {
        hash = (37 * hash) + MIN_AFTER_DEQUEUE_FIELD_NUMBER;
        hash = (53 * hash) + getMinAfterDequeue();
      }
      if (hasReadBlockLength()) {
        hash = (37 * hash) + READ_BLOCK_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + getReadBlockLength();
      }
      if (hasPrefetchSize()) {
        hash = (37 * hash) + PREFETCH_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getPrefetchSize();
      }
      if (hasNumParallelMapCalls()) {
        hash = (37 * hash) + NUM_PARALLEL_MAP_CALLS_FIELD_NUMBER;
        hash = (53 * hash) + getNumParallelMapCalls();
      }
      if (hasNumAdditionalChannels()) {
        hash = (37 * hash) + NUM_ADDITIONAL_CHANNELS_FIELD_NUMBER;
        hash = (53 * hash) + getNumAdditionalChannels();
      }
      if (hasNumKeypoints()) {
        hash = (37 * hash) + NUM_KEYPOINTS_FIELD_NUMBER;
        hash = (53 * hash) + getNumKeypoints();
      }
      if (hasMaxNumberOfBoxes()) {
        hash = (37 * hash) + MAX_NUMBER_OF_BOXES_FIELD_NUMBER;
        hash = (53 * hash) + getMaxNumberOfBoxes();
      }
      if (hasLoadInstanceMasks()) {
        hash = (37 * hash) + LOAD_INSTANCE_MASKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLoadInstanceMasks());
      }
      if (hasMaskType()) {
        hash = (37 * hash) + MASK_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + maskType_;
      }
      if (hasUseDisplayName()) {
        hash = (37 * hash) + USE_DISPLAY_NAME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDisplayName());
      }
      switch (inputReaderCase_) {
        case 8:
          hash = (37 * hash) + TF_RECORD_INPUT_READER_FIELD_NUMBER;
          hash = (53 * hash) + getTfRecordInputReader().hashCode();
          break;
        case 9:
          hash = (37 * hash) + EXTERNAL_INPUT_READER_FIELD_NUMBER;
          hash = (53 * hash) + getExternalInputReader().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.InputReaderOuterClass.InputReader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Next id: 24
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.InputReader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.InputReader)
        object_detection.protos.InputReaderOuterClass.InputReaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.InputReaderOuterClass.InputReader.class, object_detection.protos.InputReaderOuterClass.InputReader.Builder.class);
      }

      // Construct using object_detection.protos.InputReaderOuterClass.InputReader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        labelMapPath_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        shuffle_ = true;
        bitField0_ = (bitField0_ & ~0x00000004);
        shuffleBufferSize_ = 2048;
        bitField0_ = (bitField0_ & ~0x00000008);
        filenamesShuffleBufferSize_ = 100;
        bitField0_ = (bitField0_ & ~0x00000010);
        numEpochs_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        sample1OfNExamples_ = 1;
        bitField0_ = (bitField0_ & ~0x00000040);
        numReaders_ = 64;
        bitField0_ = (bitField0_ & ~0x00000080);
        numParallelBatches_ = 8;
        bitField0_ = (bitField0_ & ~0x00000100);
        numPrefetchBatches_ = 2;
        bitField0_ = (bitField0_ & ~0x00000200);
        queueCapacity_ = 2000;
        bitField0_ = (bitField0_ & ~0x00000400);
        minAfterDequeue_ = 1000;
        bitField0_ = (bitField0_ & ~0x00000800);
        readBlockLength_ = 32;
        bitField0_ = (bitField0_ & ~0x00001000);
        prefetchSize_ = 512;
        bitField0_ = (bitField0_ & ~0x00002000);
        numParallelMapCalls_ = 64;
        bitField0_ = (bitField0_ & ~0x00004000);
        numAdditionalChannels_ = 0;
        bitField0_ = (bitField0_ & ~0x00008000);
        numKeypoints_ = 0;
        bitField0_ = (bitField0_ & ~0x00010000);
        maxNumberOfBoxes_ = 100;
        bitField0_ = (bitField0_ & ~0x00020000);
        loadInstanceMasks_ = false;
        bitField0_ = (bitField0_ & ~0x00040000);
        maskType_ = 1;
        bitField0_ = (bitField0_ & ~0x00080000);
        useDisplayName_ = false;
        bitField0_ = (bitField0_ & ~0x00100000);
        inputReaderCase_ = 0;
        inputReader_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InputReader getDefaultInstanceForType() {
        return object_detection.protos.InputReaderOuterClass.InputReader.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InputReader build() {
        object_detection.protos.InputReaderOuterClass.InputReader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InputReader buildPartial() {
        object_detection.protos.InputReaderOuterClass.InputReader result = new object_detection.protos.InputReaderOuterClass.InputReader(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.labelMapPath_ = labelMapPath_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.shuffle_ = shuffle_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.shuffleBufferSize_ = shuffleBufferSize_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.filenamesShuffleBufferSize_ = filenamesShuffleBufferSize_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.numEpochs_ = numEpochs_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.sample1OfNExamples_ = sample1OfNExamples_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.numReaders_ = numReaders_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.numParallelBatches_ = numParallelBatches_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.numPrefetchBatches_ = numPrefetchBatches_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.queueCapacity_ = queueCapacity_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.minAfterDequeue_ = minAfterDequeue_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.readBlockLength_ = readBlockLength_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.prefetchSize_ = prefetchSize_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.numParallelMapCalls_ = numParallelMapCalls_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.numAdditionalChannels_ = numAdditionalChannels_;
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.numKeypoints_ = numKeypoints_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.maxNumberOfBoxes_ = maxNumberOfBoxes_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.loadInstanceMasks_ = loadInstanceMasks_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00080000;
        }
        result.maskType_ = maskType_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.useDisplayName_ = useDisplayName_;
        if (inputReaderCase_ == 8) {
          if (tfRecordInputReaderBuilder_ == null) {
            result.inputReader_ = inputReader_;
          } else {
            result.inputReader_ = tfRecordInputReaderBuilder_.build();
          }
        }
        if (inputReaderCase_ == 9) {
          if (externalInputReaderBuilder_ == null) {
            result.inputReader_ = inputReader_;
          } else {
            result.inputReader_ = externalInputReaderBuilder_.build();
          }
        }
        result.bitField0_ = to_bitField0_;
        result.inputReaderCase_ = inputReaderCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.InputReaderOuterClass.InputReader) {
          return mergeFrom((object_detection.protos.InputReaderOuterClass.InputReader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.InputReaderOuterClass.InputReader other) {
        if (other == object_detection.protos.InputReaderOuterClass.InputReader.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasLabelMapPath()) {
          bitField0_ |= 0x00000002;
          labelMapPath_ = other.labelMapPath_;
          onChanged();
        }
        if (other.hasShuffle()) {
          setShuffle(other.getShuffle());
        }
        if (other.hasShuffleBufferSize()) {
          setShuffleBufferSize(other.getShuffleBufferSize());
        }
        if (other.hasFilenamesShuffleBufferSize()) {
          setFilenamesShuffleBufferSize(other.getFilenamesShuffleBufferSize());
        }
        if (other.hasNumEpochs()) {
          setNumEpochs(other.getNumEpochs());
        }
        if (other.hasSample1OfNExamples()) {
          setSample1OfNExamples(other.getSample1OfNExamples());
        }
        if (other.hasNumReaders()) {
          setNumReaders(other.getNumReaders());
        }
        if (other.hasNumParallelBatches()) {
          setNumParallelBatches(other.getNumParallelBatches());
        }
        if (other.hasNumPrefetchBatches()) {
          setNumPrefetchBatches(other.getNumPrefetchBatches());
        }
        if (other.hasQueueCapacity()) {
          setQueueCapacity(other.getQueueCapacity());
        }
        if (other.hasMinAfterDequeue()) {
          setMinAfterDequeue(other.getMinAfterDequeue());
        }
        if (other.hasReadBlockLength()) {
          setReadBlockLength(other.getReadBlockLength());
        }
        if (other.hasPrefetchSize()) {
          setPrefetchSize(other.getPrefetchSize());
        }
        if (other.hasNumParallelMapCalls()) {
          setNumParallelMapCalls(other.getNumParallelMapCalls());
        }
        if (other.hasNumAdditionalChannels()) {
          setNumAdditionalChannels(other.getNumAdditionalChannels());
        }
        if (other.hasNumKeypoints()) {
          setNumKeypoints(other.getNumKeypoints());
        }
        if (other.hasMaxNumberOfBoxes()) {
          setMaxNumberOfBoxes(other.getMaxNumberOfBoxes());
        }
        if (other.hasLoadInstanceMasks()) {
          setLoadInstanceMasks(other.getLoadInstanceMasks());
        }
        if (other.hasMaskType()) {
          setMaskType(other.getMaskType());
        }
        if (other.hasUseDisplayName()) {
          setUseDisplayName(other.getUseDisplayName());
        }
        switch (other.getInputReaderCase()) {
          case TF_RECORD_INPUT_READER: {
            mergeTfRecordInputReader(other.getTfRecordInputReader());
            break;
          }
          case EXTERNAL_INPUT_READER: {
            mergeExternalInputReader(other.getExternalInputReader());
            break;
          }
          case INPUTREADER_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasExternalInputReader()) {
          if (!getExternalInputReader().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.InputReaderOuterClass.InputReader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.InputReaderOuterClass.InputReader) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int inputReaderCase_ = 0;
      private java.lang.Object inputReader_;
      public InputReaderCase
          getInputReaderCase() {
        return InputReaderCase.forNumber(
            inputReaderCase_);
      }

      public Builder clearInputReader() {
        inputReaderCase_ = 0;
        inputReader_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object labelMapPath_ = "";
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       */
      public boolean hasLabelMapPath() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       */
      public java.lang.String getLabelMapPath() {
        java.lang.Object ref = labelMapPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            labelMapPath_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       */
      public com.google.protobuf.ByteString
          getLabelMapPathBytes() {
        java.lang.Object ref = labelMapPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          labelMapPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       */
      public Builder setLabelMapPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        labelMapPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       */
      public Builder clearLabelMapPath() {
        bitField0_ = (bitField0_ & ~0x00000002);
        labelMapPath_ = getDefaultInstance().getLabelMapPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       */
      public Builder setLabelMapPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        labelMapPath_ = value;
        onChanged();
        return this;
      }

      private boolean shuffle_ = true;
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       */
      public boolean hasShuffle() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       */
      public boolean getShuffle() {
        return shuffle_;
      }
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       */
      public Builder setShuffle(boolean value) {
        bitField0_ |= 0x00000004;
        shuffle_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       */
      public Builder clearShuffle() {
        bitField0_ = (bitField0_ & ~0x00000004);
        shuffle_ = true;
        onChanged();
        return this;
      }

      private int shuffleBufferSize_ = 2048;
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       */
      public boolean hasShuffleBufferSize() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       */
      public int getShuffleBufferSize() {
        return shuffleBufferSize_;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       */
      public Builder setShuffleBufferSize(int value) {
        bitField0_ |= 0x00000008;
        shuffleBufferSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       */
      public Builder clearShuffleBufferSize() {
        bitField0_ = (bitField0_ & ~0x00000008);
        shuffleBufferSize_ = 2048;
        onChanged();
        return this;
      }

      private int filenamesShuffleBufferSize_ = 100;
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       */
      public boolean hasFilenamesShuffleBufferSize() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       */
      public int getFilenamesShuffleBufferSize() {
        return filenamesShuffleBufferSize_;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       */
      public Builder setFilenamesShuffleBufferSize(int value) {
        bitField0_ |= 0x00000010;
        filenamesShuffleBufferSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       */
      public Builder clearFilenamesShuffleBufferSize() {
        bitField0_ = (bitField0_ & ~0x00000010);
        filenamesShuffleBufferSize_ = 100;
        onChanged();
        return this;
      }

      private int numEpochs_ ;
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       */
      public boolean hasNumEpochs() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       */
      public int getNumEpochs() {
        return numEpochs_;
      }
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       */
      public Builder setNumEpochs(int value) {
        bitField0_ |= 0x00000020;
        numEpochs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       */
      public Builder clearNumEpochs() {
        bitField0_ = (bitField0_ & ~0x00000020);
        numEpochs_ = 0;
        onChanged();
        return this;
      }

      private int sample1OfNExamples_ = 1;
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       */
      public boolean hasSample1OfNExamples() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       */
      public int getSample1OfNExamples() {
        return sample1OfNExamples_;
      }
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       */
      public Builder setSample1OfNExamples(int value) {
        bitField0_ |= 0x00000040;
        sample1OfNExamples_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       */
      public Builder clearSample1OfNExamples() {
        bitField0_ = (bitField0_ & ~0x00000040);
        sample1OfNExamples_ = 1;
        onChanged();
        return this;
      }

      private int numReaders_ = 64;
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       */
      public boolean hasNumReaders() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       */
      public int getNumReaders() {
        return numReaders_;
      }
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       */
      public Builder setNumReaders(int value) {
        bitField0_ |= 0x00000080;
        numReaders_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       */
      public Builder clearNumReaders() {
        bitField0_ = (bitField0_ & ~0x00000080);
        numReaders_ = 64;
        onChanged();
        return this;
      }

      private int numParallelBatches_ = 8;
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       */
      public boolean hasNumParallelBatches() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       */
      public int getNumParallelBatches() {
        return numParallelBatches_;
      }
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       */
      public Builder setNumParallelBatches(int value) {
        bitField0_ |= 0x00000100;
        numParallelBatches_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       */
      public Builder clearNumParallelBatches() {
        bitField0_ = (bitField0_ & ~0x00000100);
        numParallelBatches_ = 8;
        onChanged();
        return this;
      }

      private int numPrefetchBatches_ = 2;
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       */
      public boolean hasNumPrefetchBatches() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       */
      public int getNumPrefetchBatches() {
        return numPrefetchBatches_;
      }
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       */
      public Builder setNumPrefetchBatches(int value) {
        bitField0_ |= 0x00000200;
        numPrefetchBatches_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       */
      public Builder clearNumPrefetchBatches() {
        bitField0_ = (bitField0_ & ~0x00000200);
        numPrefetchBatches_ = 2;
        onChanged();
        return this;
      }

      private int queueCapacity_ = 2000;
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean hasQueueCapacity() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       */
      @java.lang.Deprecated public int getQueueCapacity() {
        return queueCapacity_;
      }
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setQueueCapacity(int value) {
        bitField0_ |= 0x00000400;
        queueCapacity_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearQueueCapacity() {
        bitField0_ = (bitField0_ & ~0x00000400);
        queueCapacity_ = 2000;
        onChanged();
        return this;
      }

      private int minAfterDequeue_ = 1000;
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean hasMinAfterDequeue() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       */
      @java.lang.Deprecated public int getMinAfterDequeue() {
        return minAfterDequeue_;
      }
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setMinAfterDequeue(int value) {
        bitField0_ |= 0x00000800;
        minAfterDequeue_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearMinAfterDequeue() {
        bitField0_ = (bitField0_ & ~0x00000800);
        minAfterDequeue_ = 1000;
        onChanged();
        return this;
      }

      private int readBlockLength_ = 32;
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       */
      public boolean hasReadBlockLength() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       */
      public int getReadBlockLength() {
        return readBlockLength_;
      }
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       */
      public Builder setReadBlockLength(int value) {
        bitField0_ |= 0x00001000;
        readBlockLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       */
      public Builder clearReadBlockLength() {
        bitField0_ = (bitField0_ & ~0x00001000);
        readBlockLength_ = 32;
        onChanged();
        return this;
      }

      private int prefetchSize_ = 512;
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean hasPrefetchSize() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       */
      @java.lang.Deprecated public int getPrefetchSize() {
        return prefetchSize_;
      }
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setPrefetchSize(int value) {
        bitField0_ |= 0x00002000;
        prefetchSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearPrefetchSize() {
        bitField0_ = (bitField0_ & ~0x00002000);
        prefetchSize_ = 512;
        onChanged();
        return this;
      }

      private int numParallelMapCalls_ = 64;
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean hasNumParallelMapCalls() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       */
      @java.lang.Deprecated public int getNumParallelMapCalls() {
        return numParallelMapCalls_;
      }
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setNumParallelMapCalls(int value) {
        bitField0_ |= 0x00004000;
        numParallelMapCalls_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearNumParallelMapCalls() {
        bitField0_ = (bitField0_ & ~0x00004000);
        numParallelMapCalls_ = 64;
        onChanged();
        return this;
      }

      private int numAdditionalChannels_ ;
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       */
      public boolean hasNumAdditionalChannels() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       */
      public int getNumAdditionalChannels() {
        return numAdditionalChannels_;
      }
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       */
      public Builder setNumAdditionalChannels(int value) {
        bitField0_ |= 0x00008000;
        numAdditionalChannels_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       */
      public Builder clearNumAdditionalChannels() {
        bitField0_ = (bitField0_ & ~0x00008000);
        numAdditionalChannels_ = 0;
        onChanged();
        return this;
      }

      private int numKeypoints_ ;
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       */
      public boolean hasNumKeypoints() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       */
      public int getNumKeypoints() {
        return numKeypoints_;
      }
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       */
      public Builder setNumKeypoints(int value) {
        bitField0_ |= 0x00010000;
        numKeypoints_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       */
      public Builder clearNumKeypoints() {
        bitField0_ = (bitField0_ & ~0x00010000);
        numKeypoints_ = 0;
        onChanged();
        return this;
      }

      private int maxNumberOfBoxes_ = 100;
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       */
      public boolean hasMaxNumberOfBoxes() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       */
      public int getMaxNumberOfBoxes() {
        return maxNumberOfBoxes_;
      }
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       */
      public Builder setMaxNumberOfBoxes(int value) {
        bitField0_ |= 0x00020000;
        maxNumberOfBoxes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       */
      public Builder clearMaxNumberOfBoxes() {
        bitField0_ = (bitField0_ & ~0x00020000);
        maxNumberOfBoxes_ = 100;
        onChanged();
        return this;
      }

      private boolean loadInstanceMasks_ ;
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       */
      public boolean hasLoadInstanceMasks() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       */
      public boolean getLoadInstanceMasks() {
        return loadInstanceMasks_;
      }
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       */
      public Builder setLoadInstanceMasks(boolean value) {
        bitField0_ |= 0x00040000;
        loadInstanceMasks_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       */
      public Builder clearLoadInstanceMasks() {
        bitField0_ = (bitField0_ & ~0x00040000);
        loadInstanceMasks_ = false;
        onChanged();
        return this;
      }

      private int maskType_ = 1;
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       */
      public boolean hasMaskType() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       */
      public object_detection.protos.InputReaderOuterClass.InstanceMaskType getMaskType() {
        @SuppressWarnings("deprecation")
        object_detection.protos.InputReaderOuterClass.InstanceMaskType result = object_detection.protos.InputReaderOuterClass.InstanceMaskType.valueOf(maskType_);
        return result == null ? object_detection.protos.InputReaderOuterClass.InstanceMaskType.NUMERICAL_MASKS : result;
      }
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       */
      public Builder setMaskType(object_detection.protos.InputReaderOuterClass.InstanceMaskType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00080000;
        maskType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       */
      public Builder clearMaskType() {
        bitField0_ = (bitField0_ & ~0x00080000);
        maskType_ = 1;
        onChanged();
        return this;
      }

      private boolean useDisplayName_ ;
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       */
      public boolean hasUseDisplayName() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       */
      public boolean getUseDisplayName() {
        return useDisplayName_;
      }
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       */
      public Builder setUseDisplayName(boolean value) {
        bitField0_ |= 0x00100000;
        useDisplayName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       */
      public Builder clearUseDisplayName() {
        bitField0_ = (bitField0_ & ~0x00100000);
        useDisplayName_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.TFRecordInputReader, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder, object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder> tfRecordInputReaderBuilder_;
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public boolean hasTfRecordInputReader() {
        return inputReaderCase_ == 8;
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getTfRecordInputReader() {
        if (tfRecordInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 8) {
            return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
        } else {
          if (inputReaderCase_ == 8) {
            return tfRecordInputReaderBuilder_.getMessage();
          }
          return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder setTfRecordInputReader(object_detection.protos.InputReaderOuterClass.TFRecordInputReader value) {
        if (tfRecordInputReaderBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          inputReader_ = value;
          onChanged();
        } else {
          tfRecordInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 8;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder setTfRecordInputReader(
          object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder builderForValue) {
        if (tfRecordInputReaderBuilder_ == null) {
          inputReader_ = builderForValue.build();
          onChanged();
        } else {
          tfRecordInputReaderBuilder_.setMessage(builderForValue.build());
        }
        inputReaderCase_ = 8;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder mergeTfRecordInputReader(object_detection.protos.InputReaderOuterClass.TFRecordInputReader value) {
        if (tfRecordInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 8 &&
              inputReader_ != object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance()) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.TFRecordInputReader.newBuilder((object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_)
                .mergeFrom(value).buildPartial();
          } else {
            inputReader_ = value;
          }
          onChanged();
        } else {
          if (inputReaderCase_ == 8) {
            tfRecordInputReaderBuilder_.mergeFrom(value);
          }
          tfRecordInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 8;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder clearTfRecordInputReader() {
        if (tfRecordInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 8) {
            inputReaderCase_ = 0;
            inputReader_ = null;
            onChanged();
          }
        } else {
          if (inputReaderCase_ == 8) {
            inputReaderCase_ = 0;
            inputReader_ = null;
          }
          tfRecordInputReaderBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder getTfRecordInputReaderBuilder() {
        return getTfRecordInputReaderFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder getTfRecordInputReaderOrBuilder() {
        if ((inputReaderCase_ == 8) && (tfRecordInputReaderBuilder_ != null)) {
          return tfRecordInputReaderBuilder_.getMessageOrBuilder();
        } else {
          if (inputReaderCase_ == 8) {
            return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>optional .object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.TFRecordInputReader, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder, object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder>
          getTfRecordInputReaderFieldBuilder() {
        if (tfRecordInputReaderBuilder_ == null) {
          if (!(inputReaderCase_ == 8)) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
          }
          tfRecordInputReaderBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.InputReaderOuterClass.TFRecordInputReader, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder, object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder>(
                  (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_,
                  getParentForChildren(),
                  isClean());
          inputReader_ = null;
        }
        inputReaderCase_ = 8;
        onChanged();;
        return tfRecordInputReaderBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.ExternalInputReader, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder, object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder> externalInputReaderBuilder_;
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public boolean hasExternalInputReader() {
        return inputReaderCase_ == 9;
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader getExternalInputReader() {
        if (externalInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 9) {
            return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
        } else {
          if (inputReaderCase_ == 9) {
            return externalInputReaderBuilder_.getMessage();
          }
          return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder setExternalInputReader(object_detection.protos.InputReaderOuterClass.ExternalInputReader value) {
        if (externalInputReaderBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          inputReader_ = value;
          onChanged();
        } else {
          externalInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 9;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder setExternalInputReader(
          object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder builderForValue) {
        if (externalInputReaderBuilder_ == null) {
          inputReader_ = builderForValue.build();
          onChanged();
        } else {
          externalInputReaderBuilder_.setMessage(builderForValue.build());
        }
        inputReaderCase_ = 9;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder mergeExternalInputReader(object_detection.protos.InputReaderOuterClass.ExternalInputReader value) {
        if (externalInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 9 &&
              inputReader_ != object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance()) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.ExternalInputReader.newBuilder((object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_)
                .mergeFrom(value).buildPartial();
          } else {
            inputReader_ = value;
          }
          onChanged();
        } else {
          if (inputReaderCase_ == 9) {
            externalInputReaderBuilder_.mergeFrom(value);
          }
          externalInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 9;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder clearExternalInputReader() {
        if (externalInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 9) {
            inputReaderCase_ = 0;
            inputReader_ = null;
            onChanged();
          }
        } else {
          if (inputReaderCase_ == 9) {
            inputReaderCase_ = 0;
            inputReader_ = null;
          }
          externalInputReaderBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder getExternalInputReaderBuilder() {
        return getExternalInputReaderFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder getExternalInputReaderOrBuilder() {
        if ((inputReaderCase_ == 9) && (externalInputReaderBuilder_ != null)) {
          return externalInputReaderBuilder_.getMessageOrBuilder();
        } else {
          if (inputReaderCase_ == 9) {
            return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>optional .object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.ExternalInputReader, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder, object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder>
          getExternalInputReaderFieldBuilder() {
        if (externalInputReaderBuilder_ == null) {
          if (!(inputReaderCase_ == 9)) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
          }
          externalInputReaderBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder, object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder>(
                  (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_,
                  getParentForChildren(),
                  isClean());
          inputReader_ = null;
        }
        inputReaderCase_ = 9;
        onChanged();;
        return externalInputReaderBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.InputReader)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.InputReader)
    private static final object_detection.protos.InputReaderOuterClass.InputReader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.InputReaderOuterClass.InputReader();
    }

    public static object_detection.protos.InputReaderOuterClass.InputReader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<InputReader>
        PARSER = new com.google.protobuf.AbstractParser<InputReader>() {
      @java.lang.Override
      public InputReader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new InputReader(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InputReader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InputReader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.InputReader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TFRecordInputReaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.TFRecordInputReader)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    java.util.List<java.lang.String>
        getInputPathList();
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    int getInputPathCount();
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    java.lang.String getInputPath(int index);
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    com.google.protobuf.ByteString
        getInputPathBytes(int index);
  }
  /**
   * <pre>
   * An input reader that reads TF Example protos from local TFRecord files.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.TFRecordInputReader}
   */
  public  static final class TFRecordInputReader extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.TFRecordInputReader)
      TFRecordInputReaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TFRecordInputReader.newBuilder() to construct.
    private TFRecordInputReader(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TFRecordInputReader() {
      inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TFRecordInputReader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                inputPath_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000001;
              }
              inputPath_.add(bs);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          inputPath_ = inputPath_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.InputReaderOuterClass.TFRecordInputReader.class, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder.class);
    }

    public static final int INPUT_PATH_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList inputPath_;
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getInputPathList() {
      return inputPath_;
    }
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    public int getInputPathCount() {
      return inputPath_.size();
    }
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    public java.lang.String getInputPath(int index) {
      return inputPath_.get(index);
    }
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     */
    public com.google.protobuf.ByteString
        getInputPathBytes(int index) {
      return inputPath_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < inputPath_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, inputPath_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < inputPath_.size(); i++) {
          dataSize += computeStringSizeNoTag(inputPath_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getInputPathList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.InputReaderOuterClass.TFRecordInputReader)) {
        return super.equals(obj);
      }
      object_detection.protos.InputReaderOuterClass.TFRecordInputReader other = (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) obj;

      boolean result = true;
      result = result && getInputPathList()
          .equals(other.getInputPathList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getInputPathCount() > 0) {
        hash = (37 * hash) + INPUT_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getInputPathList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.InputReaderOuterClass.TFRecordInputReader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * An input reader that reads TF Example protos from local TFRecord files.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.TFRecordInputReader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.TFRecordInputReader)
        object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.InputReaderOuterClass.TFRecordInputReader.class, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder.class);
      }

      // Construct using object_detection.protos.InputReaderOuterClass.TFRecordInputReader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getDefaultInstanceForType() {
        return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader build() {
        object_detection.protos.InputReaderOuterClass.TFRecordInputReader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader buildPartial() {
        object_detection.protos.InputReaderOuterClass.TFRecordInputReader result = new object_detection.protos.InputReaderOuterClass.TFRecordInputReader(this);
        int from_bitField0_ = bitField0_;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          inputPath_ = inputPath_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.inputPath_ = inputPath_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.InputReaderOuterClass.TFRecordInputReader) {
          return mergeFrom((object_detection.protos.InputReaderOuterClass.TFRecordInputReader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.InputReaderOuterClass.TFRecordInputReader other) {
        if (other == object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance()) return this;
        if (!other.inputPath_.isEmpty()) {
          if (inputPath_.isEmpty()) {
            inputPath_ = other.inputPath_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureInputPathIsMutable();
            inputPath_.addAll(other.inputPath_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.InputReaderOuterClass.TFRecordInputReader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureInputPathIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          inputPath_ = new com.google.protobuf.LazyStringArrayList(inputPath_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getInputPathList() {
        return inputPath_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public int getInputPathCount() {
        return inputPath_.size();
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public java.lang.String getInputPath(int index) {
        return inputPath_.get(index);
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public com.google.protobuf.ByteString
          getInputPathBytes(int index) {
        return inputPath_.getByteString(index);
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public Builder setInputPath(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputPathIsMutable();
        inputPath_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public Builder addInputPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputPathIsMutable();
        inputPath_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public Builder addAllInputPath(
          java.lang.Iterable<java.lang.String> values) {
        ensureInputPathIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, inputPath_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public Builder clearInputPath() {
        inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       */
      public Builder addInputPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputPathIsMutable();
        inputPath_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.TFRecordInputReader)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.TFRecordInputReader)
    private static final object_detection.protos.InputReaderOuterClass.TFRecordInputReader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.InputReaderOuterClass.TFRecordInputReader();
    }

    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<TFRecordInputReader>
        PARSER = new com.google.protobuf.AbstractParser<TFRecordInputReader>() {
      @java.lang.Override
      public TFRecordInputReader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TFRecordInputReader(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TFRecordInputReader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TFRecordInputReader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExternalInputReaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.ExternalInputReader)
      com.google.protobuf.GeneratedMessageV3.
          ExtendableMessageOrBuilder<ExternalInputReader> {
  }
  /**
   * <pre>
   * An externally defined input reader. Users may define an extension to this
   * proto to interface their own input readers.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.ExternalInputReader}
   */
  public  static final class ExternalInputReader extends
      com.google.protobuf.GeneratedMessageV3.ExtendableMessage<
        ExternalInputReader> implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.ExternalInputReader)
      ExternalInputReaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ExternalInputReader.newBuilder() to construct.
    private ExternalInputReader(com.google.protobuf.GeneratedMessageV3.ExtendableBuilder<object_detection.protos.InputReaderOuterClass.ExternalInputReader, ?> builder) {
      super(builder);
    }
    private ExternalInputReader() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ExternalInputReader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.InputReaderOuterClass.ExternalInputReader.class, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .ExtendableMessage<object_detection.protos.InputReaderOuterClass.ExternalInputReader>.ExtensionWriter
          extensionWriter = newExtensionWriter();
      extensionWriter.writeUntil(1000, output);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.InputReaderOuterClass.ExternalInputReader)) {
        return super.equals(obj);
      }
      object_detection.protos.InputReaderOuterClass.ExternalInputReader other = (object_detection.protos.InputReaderOuterClass.ExternalInputReader) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      result = result &&
          getExtensionFields().equals(other.getExtensionFields());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.InputReaderOuterClass.ExternalInputReader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * An externally defined input reader. Users may define an extension to this
     * proto to interface their own input readers.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.ExternalInputReader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.ExtendableBuilder<
          object_detection.protos.InputReaderOuterClass.ExternalInputReader, Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.ExternalInputReader)
        object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.InputReaderOuterClass.ExternalInputReader.class, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder.class);
      }

      // Construct using object_detection.protos.InputReaderOuterClass.ExternalInputReader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader getDefaultInstanceForType() {
        return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader build() {
        object_detection.protos.InputReaderOuterClass.ExternalInputReader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader buildPartial() {
        object_detection.protos.InputReaderOuterClass.ExternalInputReader result = new object_detection.protos.InputReaderOuterClass.ExternalInputReader(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public <Type> Builder setExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, Type> extension,
          Type value) {
        return (Builder) super.setExtension(extension, value);
      }
      @java.lang.Override
      public <Type> Builder setExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, java.util.List<Type>> extension,
          int index, Type value) {
        return (Builder) super.setExtension(extension, index, value);
      }
      @java.lang.Override
      public <Type> Builder addExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, java.util.List<Type>> extension,
          Type value) {
        return (Builder) super.addExtension(extension, value);
      }
      @java.lang.Override
      public <Type> Builder clearExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, ?> extension) {
        return (Builder) super.clearExtension(extension);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.InputReaderOuterClass.ExternalInputReader) {
          return mergeFrom((object_detection.protos.InputReaderOuterClass.ExternalInputReader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.InputReaderOuterClass.ExternalInputReader other) {
        if (other == object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance()) return this;
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.InputReaderOuterClass.ExternalInputReader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.InputReaderOuterClass.ExternalInputReader) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.ExternalInputReader)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.ExternalInputReader)
    private static final object_detection.protos.InputReaderOuterClass.ExternalInputReader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.InputReaderOuterClass.ExternalInputReader();
    }

    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ExternalInputReader>
        PARSER = new com.google.protobuf.AbstractParser<ExternalInputReader>() {
      @java.lang.Override
      public ExternalInputReader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ExternalInputReader(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExternalInputReader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExternalInputReader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.ExternalInputReader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_InputReader_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_InputReader_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_TFRecordInputReader_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_ExternalInputReader_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n*object_detection/protos/input_reader.p" +
      "roto\022\027object_detection.protos\"\203\007\n\013InputR" +
      "eader\022\016\n\004name\030\027 \001(\t:\000\022\030\n\016label_map_path\030" +
      "\001 \001(\t:\000\022\025\n\007shuffle\030\002 \001(\010:\004true\022!\n\023shuffl" +
      "e_buffer_size\030\013 \001(\r:\0042048\022*\n\035filenames_s" +
      "huffle_buffer_size\030\014 \001(\r:\003100\022\025\n\nnum_epo" +
      "chs\030\005 \001(\r:\0010\022!\n\026sample_1_of_n_examples\030\026" +
      " \001(\r:\0011\022\027\n\013num_readers\030\006 \001(\r:\00264\022\037\n\024num_" +
      "parallel_batches\030\023 \001(\r:\0018\022\037\n\024num_prefetc" +
      "h_batches\030\024 \001(\005:\0012\022 \n\016queue_capacity\030\003 \001" +
      "(\r:\0042000B\002\030\001\022#\n\021min_after_dequeue\030\004 \001(\r:" +
      "\0041000B\002\030\001\022\035\n\021read_block_length\030\017 \001(\r:\00232" +
      "\022\036\n\rprefetch_size\030\r \001(\r:\003512B\002\030\001\022&\n\026num_" +
      "parallel_map_calls\030\016 \001(\r:\00264B\002\030\001\022\"\n\027num_" +
      "additional_channels\030\022 \001(\005:\0010\022\030\n\rnum_keyp" +
      "oints\030\020 \001(\r:\0010\022 \n\023max_number_of_boxes\030\025 " +
      "\001(\005:\003100\022\"\n\023load_instance_masks\030\007 \001(\010:\005f" +
      "alse\022M\n\tmask_type\030\n \001(\0162).object_detecti" +
      "on.protos.InstanceMaskType:\017NUMERICAL_MA" +
      "SKS\022\037\n\020use_display_name\030\021 \001(\010:\005false\022N\n\026" +
      "tf_record_input_reader\030\010 \001(\0132,.object_de" +
      "tection.protos.TFRecordInputReaderH\000\022M\n\025" +
      "external_input_reader\030\t \001(\0132,.object_det" +
      "ection.protos.ExternalInputReaderH\000B\016\n\014i" +
      "nput_reader\")\n\023TFRecordInputReader\022\022\n\nin" +
      "put_path\030\001 \003(\t\"\034\n\023ExternalInputReader*\005\010" +
      "\001\020\350\007*C\n\020InstanceMaskType\022\013\n\007DEFAULT\020\000\022\023\n" +
      "\017NUMERICAL_MASKS\020\001\022\r\n\tPNG_MASKS\020\002"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
    internal_static_object_detection_protos_InputReader_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_object_detection_protos_InputReader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_InputReader_descriptor,
        new java.lang.String[] { "Name", "LabelMapPath", "Shuffle", "ShuffleBufferSize", "FilenamesShuffleBufferSize", "NumEpochs", "Sample1OfNExamples", "NumReaders", "NumParallelBatches", "NumPrefetchBatches", "QueueCapacity", "MinAfterDequeue", "ReadBlockLength", "PrefetchSize", "NumParallelMapCalls", "NumAdditionalChannels", "NumKeypoints", "MaxNumberOfBoxes", "LoadInstanceMasks", "MaskType", "UseDisplayName", "TfRecordInputReader", "ExternalInputReader", "InputReader", });
    internal_static_object_detection_protos_TFRecordInputReader_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_TFRecordInputReader_descriptor,
        new java.lang.String[] { "InputPath", });
    internal_static_object_detection_protos_ExternalInputReader_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_ExternalInputReader_descriptor,
        new java.lang.String[] { });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
